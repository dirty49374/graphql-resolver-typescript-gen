
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';

// this file is generated by code generator

// scalar types -----------------------------
export type Scalars = {
  Boolean: any;
  Date: any;
  ID: string;
  String: string;
}


// union types ------------------------------
export type SearchResult =
  | User
  | Chat
  | ChatMessage
  ;


// enum types -------------------------------
export enum Role {
  User = 'USER',
  Admin = 'ADMIN',
};


// object types -----------------------------
export interface Chat  {
  __typename?: 'Chat';
  id: string;
}

export interface ChatMessage  {
  __typename?: 'ChatMessage';
  id: string;
}

export interface Directory  {
  __typename?: 'Directory';
  id: string;
}

export interface File  {
  __typename?: 'File';
  id: string;
}

export interface Mutation  {
  __typename?: 'Mutation';
  xx: string;
}

export interface Query  {
  __typename?: 'Query';
  me: User;
  user: User;
  allUsers?: (User | null)[] | null;
  search: SearchResult[];
  myChats: Chat[];
}

export interface Subscription  {
  __typename?: 'Subscription';
  yy: string;
  zz: string;
}

export interface User  {
  __typename?: 'User';
  id: string;
  username: string;
  email: string;
}


// interface types --------------------------
export type Node =  {
  __typename?: 'Node';
  id: string;
}


// input types ------------------------------
export type Xyz = {
  id: string;
}


// resolver types ---------------------------



export type ChatResolver<TContext = any> = {
  users: (parent: Chat, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<User[]> | User[];
  messages: (parent: Chat, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<ChatMessage[]> | ChatMessage[];

  __isTypeOf?: (obj: Chat, context: TContext, info: GraphQLResolveInfo) => Promise<boolean> | boolean;
};





export type ChatMessageResolver<TContext = any> = {
  content: (parent: ChatMessage, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<string> | string;
  time: (parent: ChatMessage, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<any> | any;
  user: (parent: ChatMessage, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<User> | User;

  __isTypeOf?: (obj: ChatMessage, context: TContext, info: GraphQLResolveInfo) => Promise<boolean> | boolean;
};



export type DirectoryResolver<TContext = any> = {
  files: (parent: Directory, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<File[] | null> | File[] | null;

  __isTypeOf?: (obj: Directory, context: TContext, info: GraphQLResolveInfo) => Promise<boolean> | boolean;
};



export type FileResolver<TContext = any> = {
  

  __isTypeOf?: (obj: File, context: TContext, info: GraphQLResolveInfo) => Promise<boolean> | boolean;
};

export type MutationXxArgs = {
  arg?: string | null
  arg2?: string | null;
};

export type MutationResolver<TContext = any> = {
  xx: (parent: Mutation, args: MutationXxArgs, context: TContext, info: GraphQLResolveInfo) => Promise<string> | string;

  __isTypeOf?: (obj: Mutation, context: TContext, info: GraphQLResolveInfo) => Promise<boolean> | boolean;
};


export type QueryUserArgs = {
  id: string;
};

export type QuerySearchArgs = {
  term: string;
};


export type QueryResolver<TContext = any> = {
  me: (parent: Query, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<User> | User;
  user: (parent: Query, args: QueryUserArgs, context: TContext, info: GraphQLResolveInfo) => Promise<User> | User;
  allUsers: (parent: Query, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<(User | null)[] | null> | (User | null)[] | null;
  search: (parent: Query, args: QuerySearchArgs, context: TContext, info: GraphQLResolveInfo) => Promise<SearchResult[]> | SearchResult[];
  myChats: (parent: Query, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<Chat[]> | Chat[];

  __isTypeOf?: (obj: Query, context: TContext, info: GraphQLResolveInfo) => Promise<boolean> | boolean;
};




export type SubscriptionResolver<TContext = any> = {
  yy: {
    subscribe: (parent: any, args: {}, context: TContext, info: GraphQLResolveInfo) => AsyncIterable<string> | Promise<AsyncIterable<string>>,
    resolve: (parent: string, args: {}, context: TContext, info: GraphQLResolveInfo) => string,
  },
  zz: {
    subscribe: (parent: any, args: {}, context: TContext, info: GraphQLResolveInfo) => AsyncIterable<string> | Promise<AsyncIterable<string>>,
    resolve: (parent: string, args: {}, context: TContext, info: GraphQLResolveInfo) => string,
  },

  __isTypeOf?: (obj: Subscription, context: TContext, info: GraphQLResolveInfo) => Promise<boolean> | boolean;
};



export type UserResolver<TContext = any> = {
  role: (parent: User, args: {}, context: TContext, info: GraphQLResolveInfo) => Promise<Role> | Role;

  __isTypeOf?: (obj: User, context: TContext, info: GraphQLResolveInfo) => Promise<boolean> | boolean;
};


// all resolvers ----------------------------
export type Resolvers<TContext = any> = {
  Chat: ChatResolver<TContext>;
  ChatMessage: ChatMessageResolver<TContext>;
  Directory: DirectoryResolver<TContext>;
  File?: FileResolver<TContext>;
  Mutation: MutationResolver<TContext>;
  Query: QueryResolver<TContext>;
  Subscription: SubscriptionResolver<TContext>;
  User: UserResolver<TContext>;
};
